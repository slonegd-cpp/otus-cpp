Вопросы
Проверяем на модифицируемость:

  A. сколько файлов будет изменено
  AA. добавлено
  B. сколько функций будет изменено
  BB. добавлено
  C. сколько классов будет изменено
  CC. добавлено.

Для следующих новых требований:
  1. Вам требуется реализовать два новых графический примитива.
  2. Вам требуется добавить импорт/экспорт документа из/в базы(у) данных.
  3. Вам требуется добавить модификацию существующего в документе
     примитива, например, изменение размера/цвета/...
  4. Вам требуется добавить новую обработку документа, например, замена
     одних графических примитивов на новые по определенному правилу.


Проверяем на тестируемость:

  A. сколько файлов будет изменено
  AA. добавлено
  B. сколько функций будет изменено
  BB. добавлено
  C. сколько классов будет изменено
  CC. добавлено.

в текущем коде (не считаем то, что относится к тесту:
сценарии/функции тестирования, мок-классы, мок-объекты и т.д.).
  1. Вам требуется проверить работу хранилища документа: файловая система, база данных.
  2. Вам требуется проверить чтение шаблонного документа и его сохранения.
  3. Вам требуется проверить новую обработку документа.
  4. Вам требуется проверить отображение разных графических примитивов.

Добавьте каркасы тестовых случаев, т.е. только названия.
И требуемых и своих.

Ответы проверки на модифицируемость

1: Вам требуется реализовать два новых графический примитива.
А  будет изменён 1 файл figures.h
AA файлы не добавятся
B  поскольку появятся 2 новых поля перечисления, то возможно изменится
    перегрузка вывода в поток, где надо добавить новые случаи. Но это зависит от
    реализации самой перегрузки.
BB функций не добавится
С  классы изменены не будут
СС будут добавлены классы новых примитивов

2: Вам требуется добавить импорт/экспорт документа из/в базы(у) данных.
А  изменится файл user.h (добавить новые действия) и document.h
АА файлы не добавятся
B  функции изменены не будут
BB добавятся методы в User, поскольку он должен указать откуда в базе
    данных нужно взять данные. Добавятся методы преобразования данных
    в документ и обратно.
С  изменится класс User, Document
CC классы не добавятся

3: Вам требуется добавить модификацию существующего в документе
   примитива, например, изменение размера/цвета/...
Комментарий: размер и цвет приведут к разным изменениям. Далее пишу про размер.
Для цвета нужно добавлять это поле в класс примитива, когда как размер определяется уже
имеющимися полями.
A  изменится файл user(указывает, что сделать) figures(сделать изменения)
АА добавится файл с преобразованиями примитивов
B  существующие функции не будут изменены
ВВ добавятся функции преобразования размера, которые будут принимать
   ссылку на примитив (функции зависят от типа).
С  изменится User
СС не будет добавлено новых классов

4: Вам требуется добавить новую обработку документа, например, замена
   одних графических примитивов на новые по определенному правилу.
Комментарий: нужно добавить обход по всем примитивам документа, с
возможностью замены всех его полей, вплоть до типа. То есть функция
должна примимать ссылку на строку в документе. "определённые правила"
очень обобщённая формулировка. Потому изменения зависят от этих правил.
Думаю проще сделать набор функций фильтров.
А  изменится файл user(указывает, что сделать), document (обход по всем фигурам)
АА добавится файл с функциями фильтрами
B  имеющиеся функции изменены не будут
ВВ добавятся методы в User и Document, функции-фильтры
С  изменится User, Document
СС не будет добавлено новых классов


Ответы проверки на тестируемость:

1. Вам требуется проверить работу хранилища документа: файловая система, база данных.
В моём проекте нет классов хранилища документа. Предполагалось, что
пользователь указывает файл документа и он доступен.
A.  файлы не будут изменены
AA. добавлены файлы тестов, файл класса работы с базой данных
B.  функции не будут изменены
BB. функции не будут добавлены
C.  изменится класс User, поскольку над добавить взаимодействие с классом
    базы данных
CC. добавится класс работы с базой данных

2. Вам требуется проверить чтение шаблонного документа и его сохранения.
А.  файлы не будут изменены
AA. будет добавлен файл с тестами, эталонный документ
В.  функции изменены не будут
ВВ. новые функции не добавятся
С.  классы изменены не будут
СС. классы не добавятся

3. Вам требуется проверить новую обработку документа.
А.  файлы не будут изменены
AA. будет добавлен файл с тестами
В.  функции изменены не будут
ВВ. новые функции не добавятся
С.  классы изменены не будут
СС. классы не добавятся

4. Вам требуется проверить отображение разных графических примитивов.
A.  файлы изменены не будут
AA. будет добавлен файл с тестами
B.  функции изменены не будут
BB. новые функции не добавятся
C.  изменятся классы фигур, их методы draw надо приести к работе с контроллером экрана
CC. надо добавить класс контроллера экрана, чтобы была возможность сравнения
    отображение с неким шаблоном


ДЗ принимаю. Вы поработали и подумали - это главное.
Не буду требовать от вас сильного внимания к ДЗ-05.
Проектирование это достаточно сложно, чтобы рассмотреть все вопросы в одном ДЗ.
Но все же подумайте над следующим:
Основное замечание по ответам:
когда мы проверяем на тестируемость, то самое важное это эмуляция.
Например эмуляция действий пользователей, эмуляция работы с базой данных и т.д.
Вы ведь не собираетесь в тесте обращаться к реальной базе данных!
Соответственно реальные объекты/классы заменяются на “мок” объекты/классы.
Соответственно должна быть фабрика классов, которая в режиме тестирования
будет создавать эти “мок” объекты/классы вместо “рабочих”.
Поэтому, когда вы пишите, что ничего изменять в коде не требуется при тестировании,
то это значит, что вы еще не понимаете как будет развиваться ваш прототип.
И насколько важна тестопригодность кода.
При модификации тоже есть важные пробелы.
Приведу один пример: если вы создали новый графический примитив,
то его лучше реализовать в отдельном файле.
Т.е. при модификации предпочтение отдается “добавлению”.

a. (+) Каркасов тестов немало
Вообще проработка прототипа начинается с составления use-cases,
т.е. поведенческой модели. В use-cases выделяются actors, и т.д. и т.п.
Далее проработка domain-model - т.е. набор сущностей предметной области -
это предметная модель. Далее связывается поведенческая (динамическая)
и предметная (статическая) модели. Попробуйте словами описать UC
“удаление графического примитива”.
Начните со слов: “Пользователь указывает графический примитив...”
b. (!) Используйте Pimpl для разделения реализации и интерфейса.
Хотелось бы видеть больше интерфейсов, т.е. абстрактных классов,
в которых бы и было зашито взаимодействие между компонентами.
А реализацию отвести, например, на Pimpl. А также хотелось бы
видеть разбиение на компоненты с реализацией соответствующих интерфейсов.
c. (!) Помните про SOLID. Главное в этом принципе, что новая функциональность
добавляется при этом старое поведение не меняется. В наше время это
добивается работой через интерфейсы, которые у вас прописаны слабо.
Для прототипа требуется спроектировать только разбиение на интерфейсы
и компоненты. Ответьте себе на вопрос: Графический примитив сам себя рисует
(см. функцию draw), ни на чем, никак не связан ни с окном ни с документом…
А вот эти связи и их выбор - это и есть вопросы проектирования
d. (!) Присмотритесь к моделям MVC, MVP, MVVM
e. (!) Обратите внимание на принцип: Tell Dont Ask! См. https://habr.com/sandbox/60101