a. (+) Тесты хорошие, но пару замечаний сделаю:
тесты фиксируют порядок прохода по всем занятым ячейкам,
но в задаче это не требуется. Т.е. при проведении рефакторинга
придется не забыть, что тест на вывод элементов может проваливаться.
Можно хотя бы добавить комментарий в тест.
Тест кейсы лучше делать отдельные и вместо комментариев выбирать
соответствующее название тест-кейсов.
b. (-) Добейтесь работы следующего кода:
for(const auto& c: matrix) { 
    int x; int y; int v;
    std::tie(x, y, v) = c;
    stream << '[' << x << "][" << y << "]=" << v << std::endl;
}
с. (-) Сделайте константным оператор приведения:
Element::operator std::tuple<int&,int&,T&>()
d. (-) Сделайте константным оператор взятия по индексу:
Matrix::operator [] (int x)
e. (-) Сделайте константным оператор взятия по индексу:
Matrix::X1::operator [] (int x)
f. (-) Избавьтесь от структуры: struct Matrix::X1
Пусть Matrix::operator [] (int x) возвращает сразу структуру X1X2.
g. (!) Когда все это сделаете, возможно, увидите путь к n-мерной матрицы.

ответы
а. добавил sort перед печатью. Оформил Тест кейсы.
b. добился )
с. оператор приведения больше не использую.
d. не могу, поскольку внутри сохраняю координату
e. этот метод перенесён по замечанию f
f. избавился
g. не смог сделать контсантными операторы взятия по индексу, но n-мерную
матрицу всё таки реализовал.

h. (!) В таком выражении расставляйте скобки, даже если знаете,
что работает и без скобок.
    return lx1 < rx1 or lx1 == rx1 and lx2 < rx2;
i. (!) Сделайте константным operator [] или добавьте константный.
j. (!) Конфьюзят похожие названия using Element_t struct Element
k. (!) Подумайте об использовании weak_ptr вместо Elements<T,n>* elements;
Возможно даже придется использовать shared_from_this()

ОЦЕНКА. Запросите собственный результат у автора комментария
"Если хочется поизучать: по поводу эффективности решения, проверил матрицу на вставку 10.000 элементов,
время: 2479 миллисекунд. Многовато показалось." Обсудите, почему так сильно разнятся результаты.

Ответ
Вставка в лист дорого стоит, лучше использовать set или map.
Добавил тест на производительность, когда руки дойдут можно будет определить
сейчас тест выдаёт
result: 2349 ms