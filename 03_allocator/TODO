a. (+-) Тестов маловато. Первое на, что я смотрю - это на тесты.
Если по представленным тестам могу ответить на вопрос: задание выполнено верно? -
то тесты хорошие. Если ответа на такой вопрос найти не смог или было сложно
однозначно ответить на него - то тесты сомнительны. Вот, как у вас сейчас.
Всё, что вы тестируете в тестах, для самих тестов должно быть “черным ящиком”.
Т.е. проверять BOOST_CHECK ((p[0] + 2) == p[2]); - это проверять реализацию,
т.е. внутреннее строение аллокатора, что неверно. Если бы было специальное
требование, что выдача памяти должна быть последовательной, тогда этот тест
еще мог иметь право на жизнь. Когда создается специальный функционал на выделение
памяти, то желательно иметь тесты на утечки памяти. Вспомните пример, который
мы обсуждали на вебинаре https://goo.gl/PmMMwF. Можно воспользоваться
специальными функциями my::malloc и my::free, чтобы определить в тесте всю ли
память вы отдали! Это же относиться и к вашему контейнеру. 
b. (-) Вы попали в ловушку! Использование в вашем аллокаторе
std::vector<T> allocated; будет вызывать для T лишний конструктор, что не верно.
Нам нужно выделить память. с. (-) Избегайте дублирования кода. Напрашивается
constexpr-функция для вычисления факториала. Помните, что преждевременная
оптимизация может повредить. 
d. (-) Попробуйте уйти от использования голых указателей в вашем контейнере.
e. (-) Напрашивается использование std::generate_n, std::inserter.
Ясность решений - это не простота конструкций, а использование таких стандартных
конструкций, которые явно показывают ваши намерения.
f.(!) Попробуйте доработать ваш аллокатор до полноценного, который бы работал
и с std::vector, и который бы поддерживал полноценную работу с std::map,
т.е. операции вставки и удаления и т.д.
g. (!) Подумайте над тестами на производительность, чтобы сравнить работу
с вашим аллокатором и со стандартным
h. (!) подумайте над тестами на утечки памяти, как при работе с вашим аллокатором
так и при работе с вашим контейнером

Ответы:
а. Во всём согласен. Тесты переделал.
b. больше конструктора T нет.
с.e. Переписал. В оправдание своего прошлого подхода могу сказать, что не был уверен,
что функция факториала будет рассчитана на этапе компиляции, поэтому сознательно
отказался в первый раз от её использования.
d. Всё таки голый указатель остался (сишный массив), но такая запись мне кажется
менее нагруженной, чем с использованием std::array и взятие адреса.
f. Попробовал и всё поломал. Дело в том, что в моём контейнере хранится указатель
на следующий элемент, и при простом побайтовом копировании, когда выделяется
новая память сверх зарезервированной, эти указатели остаются старыми и указывают
не туда. Есть идея хранить не указатели а смещение на следующий элемент относительно
текущего, но я её не решился реализовывать.
g. Для таких тестов у меня пока недостаточно знаний. Я не знаю как измерять время. (
h. Тест на утечку памяти контейнера показал, что утечка есть. Доработал контейнер.

a.(+-) Тесты все же явно не показывают выполнения требований задания. В требованиях
говорится о работе с map!
i.(!) https://goo.gl/rDfNXp - это усложнение. Достаточно взять значение переменной
my::alloc_counter до работы с контейнером и после (но до уничтожения контейнера).
j.(-) Почему вместо char [sizeof(T)] - не использовать std::array
(какое-то смешение старых и новых подходов)
k.(!) Опционально: реализуйте полноценный аллокатор. Это позволит вам в будущем
ссылаться на вашу реализацию, чтобы показать, что вы умеете работать с памятью!
k.(-) Желательно уйти от голых указателей!

В оценке очень важное замечание, на мой взгляд:
Не выполнено требование задания
“Контейнер должен иметь две возможности - ... и обойти контейнер в одном направлении”.
Ревьюер указывает на отсутствие поддержки итераторов. Но как бы это ни называлось,
не реализована возможность последовательного доступа к элементам контейнера от условно
первого до условно последнего. Именно это и подразумевает “возможность обойти контейнер”.
При этом в двух методах класса контейнера (foreach и в деструкторе) этот обход совершается.

Из Оценки (Кудинов Александр) видно, что код очень сырой и для промышленного использования
не готов! Согласен с вами, что это всего лишь задание на курсе. Но в этом задании мы качаем
и навыки разработчика. Умение делать простое, но законченное решение за приемлемое время -
очень высоко ценится! Стремитесь к этому!